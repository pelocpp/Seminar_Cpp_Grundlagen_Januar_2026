Seminar C++ Grundlagen und weiterführende Aspekte
=================================================

Peter Loos

30+ Jahre // 20 Jahre Production (C/C++)
             20 Teaching // Java, C#, JavaScript, Mobile Apps (Android), Flutter (Dart)

Knapp 20 Jahre: Siemens Technik Akademie 



Back-to-the-Roots: C++

== Classic C++
== Modern C++ (C++ 11)


C# -- Kenntnisse

Java, Python, Unity, TypeScript (JavaScript)

Welche Sprachen ...
=> Umstieg von C# nach C++
Was sind meine Erwartungen ...
Was MUSS drin sein ...
Was brauche ich ...

Ziel: C++ kennen lernen

=====================================================

ToDo-Liste:

this: check

=====================================================

Mittagspause: 12.30 

10.30   // 15.00 ....

=====================================================

2 Tools:

a) Unterlagen:

   Github:

   https://github.com/pelocpp

b) Visual Studio Community (2022 / 2026)

=====================================================


3 Tage C++ Komplett

a) C++ Grundlagen

b) Modern C++


=====================================================

Beobachtung:

Java, C#, Python:

   ==> Höherstehenden Schichten eines SW-Architektur
       zB: Backend Web-Server // Desktopanwendung (C# / .NET Framework)


C++:

   ==> Tiefere Schichten eines SW-Architektur

   Embedded SW // System-SW // Hardware-nahe SW // Desktopanwendung
   System Tools:  Compiler , Debugger  


=====================================================

Beobachtung:

C:  ca. 1980

    Keine OO // rein prozedural

C++: ca. 1985

C ist vom Sprachumfang ECHT in C++ enthalten. (99%)

Konsequenz:

Manche Sprachmittel gibt es in C++ doppelt:

== Pointer   ( C )
== Referenz  ( C++ )

Fazit: Habe ich so eine Situation gegeben: C++ Sprachmittel (nicht: C)

=====================================================


Architektur:
============

Ein Vergleich von C# und C++:

C#: Virtuelle Maschine (CLR)

2 Übersetzungsvorgänge:

A) C# ==> IL

B) JIT: Just-in-Time Compiler: IL => Maschinecode

-----------------------------------------------------

C++:  C++ => Maschinecode

Tooling:

i)  C++ - Compiler
ii) Linker

Verfeinerung:
-------------

Ein C++ Projekt besteht aus vielen Dateien.

C++ => binäres Format (.obj-File // o.-Files )

Spezifikation:  Common Object File Format

Linker: Viele .obj-Dateien ==> Maschinencode (.exe)

Bemerkung:

a) Es gibt Syntax-Fehler:  Grammatik ("compile")
b) Es gibt Linker-Fehler:  zB doppeltes main

==============================================================

Wo liegen Objekte in einem C## / C++ - Programm ???

Im Speicher :)

== Globale Daten
== Stack
== Heap

==============================================================

Stack: Ist ein Speicherbereich :)

Kann nicht wahlweise zugegriffen werden ?!?!?

Nur über den Stackpointer:

Wort Stapel:  Bücherstapel

Wozu ist der Stack so konzipiert ??????

A) Lokale Variablen zu realisieren.
b) Wo geht es nach einem Unterprogrammaufruf weiter ???????

   Es werden PRO Aufruf eines Unterprogramms die Rücksprungadressen
   auch auf dem Stapel abgelegt.


Worüber reden wir gerade:  Stackframe

==============================================================

Heap:

Ist auch ein Speicherbereich.

Wie wird auf den Heap zugegriffen ???

Identisch: C# / C++   Allgemeinen Fall  (  C#:  class  )

new   ==>  Heap  

AUSNAHME:   (( struct:   Stack ))

==============================================================

Stack: Ist ein Speicherbereich :)

Uhhhh: Ein Detail in C#: struct vs. class // Stack vs. Heap

Beispiele:

int malZwei (int a)
{
   int tmp = a;  // Stack
   tmp = 2 * a;
   return tmp;
}

main ()
{
   int a1 = malZwei(5);
   ...

   ....

   int a2 = malZwei(10);
   ...

}


=======================================================

ACHTUNG // VERGLEICH

C#  ===> C++

Klasse Rectangle:   class Rectangle


void tueWas_CSharp()
{
    Rectangle rect1;    // rect ist eine "Referenz" // Pointer // Adresse

    Rectangle rect2 = new Rectangle(10, 20, 40, 50);
}

Eine Referenz ist ein Doppel-Zeiger:  

Zeiger ==> Bucket-Liste // Liste der Objekt-Adressen // ==> Zeiger der tatsächlichen Objekte

new: 2 Funktionalitäten:

     a) Speicher auf dem Heap bereitstellem
     b) Den Konstruktor auf diesem Stück Speicher ausführen

Wann wird dieses Objekt freigegeben:

     a) Wenn es KEINE REFERENZ (Pointer) mehr gibt, der auf dieses Objekt zeigt.

     b) Wer gibt das Unterprogramm frei: SW:  Garbage Collector // GC

        ==> Es gibt in der Tat mehrere REALISIERUNGEN eines solchen GC

        a) Desktop Variante:   Faule Variante (Lazy): Erst, wenn der Speicher knapp wird
        b) Embedded Variante:  Zügig, um Engpässe im Speicher zu vermeiden.

// ----------------------------------------------

// C Sharp
void tueWas_CSharp()
{
    Rectangle rect;    // rect ist eine "Referenz" // Pointer // Adresse // null
}

// C++
void tueWas_Cpp()
{
    // dieses Objekt liegt am STACK
    Rectangle rect1 (10, 10, 30, 40);    // rect ist ein vollständiges Objekt // liegt am STACK !!!

    // dieses Objekt liegt am HEAP
    // In C++ muss der Typ POINTER konkret definiert werden
    Rectangle* rect2 = new Rectangle (10, 10, 30, 40);

   // delete rect2;
}

Gretchenfrage: Wer gibt (C++) das Objekt am Heap  (rect2)  wieder frei ???
   Wir // der entwickler // es muss EXPLIZIT im Programm freigegeben werden !!!


ARCHITEKTUR:

C#:     Referenz-baasierte Sprache  (Heap  // new // GC )

C++:    Referenz-baasierte Sprache  (Heap  // new // delete)

        Stack-basierte Sprache      (Stack)

===========================================================

Ein C++ Projekt mit Visual Studio:

a) Grammatik / Syntax

   == Compile

b) Das Programm bauen

   == Build

Vergleich:

C#:   2-Pass Compiler

C++:  1-Pass Compiler

Alles muss bei einem Übersetzungsdurchlauf bekannt sein !!!

===========================================================

Ein objekt-orientiertes Programm in C++
---------------------------------------

Klasse:  2 Dateien

a) Header-Datei

   ===> Kunden // Benutzer

b) Implementierungs-Datei

   ===> Library // Binärformat

Beispiel:

Uhrzeit:  Klasse Time

Stunden, Minuten und Sekunden.

=============================

Ab C++ 20 / 23:  

The Return of printf (C#:  println)   // Python

============================

C++ Bibliothek:   STL   Standard Template Library

Template == ähnlich zu Generics

=========================================================

C#: Sprachfeature: Property  // implicit get / set

C++: So nicht vorhanden.

   getter / setter

=========================================================

Ein Kern Feature der OO:

Jeder Objekt hat zu JEDEM Zeitpunkt GÜLTIGE Werte in seinen
Instanzvariablen.

a) Initialisierung (Konstruktoren)

b) Während des Lebensdauer eines Objekts (getter/setter // Analogie: Properties C#)


=========================================================

Zu Konstruktoren:

A) Hat die Klasse KEINEN Konstruktor definiert:

   Dann wird der Standard-Konstruktor AUTOMATISCH erzeugt.

   Vorsicht: KEINE Vorbelegung mit Null !!!!!!!!!!!!!!

B) Hat die Klasse EINEN oder MEHRERE Konstruktor definiert:

   Dann sind nur die verfügbar, die es auch gibt.

==============================================================

Stilistik:

this:  Konzipiert als ZEIGER auf das aktuelle Objekt.

class Time:

Time* this;

==============================================================

Aufgabe:

Bankkonto

class BankAccount

== Member: m_balance (double, int)

== Einzahlen, Abheben, Ausgeben

== getter: getBalance

2 Dateien: Header-File, Implementierungs-File

3. Datei: Programm: 

=================================================================

Header-Datei:

Ausnahme von der Regel:

Methoden sind im Header-File implementierbar.

Pro:

== Einfachere Hantierbarkeit

Kontra:

== Eigentlich ist das Header-File für den Benutzer der Klasse konzipiert.
   (  inkl. der Implementierung ??? )

=================================================================

Übergabe von Objekten an Methoden
---------------------------------

Parameterübergabe:
------------------


ARCHITEKTUR:

C#:     Referenz-basierte Sprache  (Heap  // new // GC )

C++:    Referenz-basierte Sprache  (Heap  // new // delete)

        Stack-basierte Sprache      (Stack)


C++ / C:

Parameterübergabe: Per DEFAULT: Call-by-VALUE // Call-by-COPY

Wie kann man in Unterprogrammen auf ORIGINALE zugreifen ?????????????

Wir haben per Default:  Call-by-COPY

2 Lösungen:

A) Pointer   ( C )     // real C/C++


new: <================ Pointer



Wert hinter der Adresse:   05 00 00 00

                            0a 00 00 00




B) Referenz  ( C++ )   // leichter lesbare / schreibbare Weise 

Merkhilfe: Eine Referenz ist im Prinzip die ADRESSE einer Variablen,
            nur mit einer anderen Schreibweise (leichter lesbar sein)

Fazit:

Wozu Referenzen:

Um am STACK Objekte mit ihren ADRESSEN zu bewegen.

Was ist mit dem HEAP ???

Hier gibt es nur POINTER, die mit new ermittelt werden.

Eine Kopie eines Pointers ist KEINE Kopie eines Objekts.

=====================================

Adresse:

void*: Das gibt es so nicht

int*:  Eine int-Variable belegt 4 Bytes im Speicher // sizeof

       Damit sind bei einer int* Adresse  4 BYTEs relevant.


Wert hinter der Adresse:   05 00 00 00

                           0a 00 00 00


// ===================================================

Was ist ein cast:  Typumwandlung ...


========================================================

C:   Pointer-Arithmetik
     Adress-Arithmetik


         ++ip;   Man kann eine Adresse als ganze Zahl auffassen.
                 Folglich kann man 1 draufzählen.

                 1024 => 1025: NEIN
                 1024 => 1028: Korrekt

Wann brauche ich die Adress-Arithmetik:

Bei dynamscher Speicherverwaltung:

new : 100 int Werte  ==> Anfangsadresse.

=======================================================

Anwendung von Referenzen:
-------------------------

Feature:  Schutz von Objekten // 95%: Das gibt es so in C# nicht ....

=========================================================

'int Time::getHours(void)': 

cannot convert 'this' pointer from 'const Time' to 'Time &'

Trick / Hinweis: wenn in der Fehlermeldung 'const' steht, dann ist das in der Regel ein FEHLENDES const.

Frage / Problem: Wo ???

Beobachtung: Einmal 'const', immer 'const'

=========================================================

Ist const nur für die Qualität des Codes (Schutz von Originalen) eine Hilfe ???

NEIN.

2 Aspekt:

Funktionale Programmiersprachen:  Ge-hyped

Performanz:  Merkmal einer Funktion:  Kennt keine Instanzvariablen.

Optimierung:  Pipelining.

Geht nicht bei OO:  ==> State // Member

Ausnahme:  'const'  ==> KEIN schreibender Zugriff auf State

 ==> besser optimieren.

80%:  Java, C#, C++ ...........

// =========================================================

Call by Referenz ist wichtig bei Objekten:

KEINE unnütze Kopie.

Wie sieht es bei elementaren Variablen aus ???

Hier ist call-by-Copy SCHNELLER

EAX: Akku // Rechenregister einer CPU // Hauptregister

RAX:  Register für Adressen

Call-by-Copy:

    int m = value;
00007FF7434B755F  mov         eax,dword ptr [value]  
00007FF7434B7565  mov         dword ptr [m],eax  


Call-by-Ref:

    int m = value;
00007FF7434B75F0  mov         rax,qword ptr [value]  
00007FF7434B75F7  mov         eax,dword ptr [rax]  
00007FF7434B75F9  mov         dword ptr [m],eax  

==============================================================

Überladen von Operatoren

Beispiel:

Vergleich von Objekten

C#:

Universelle Basisklasse Object:   equals  // Überschreiben

Ähnliches zu einem speziellen Operator:  Indexer  // Ähnlich zum operator[]

C++:

operator ==

Technisch:  

Wie das Schreiben einer Methode
Name der Methode:  operator ==

BEMERKUNG: 

Es gibt ZWEI Möglichkeiten, Operatoren zu Überladen:

a) Als "Methode" der Klasse

B) Als globale Funktion


=================================================================

Scharfes Schwert:   friendship   Keyword:   friend       // Clean Code 

Für "Freunde" gilt: Aus private wird public :)

=================================================================


Dynamische Daten

== new und delete

ACHTUNG:

Es gibt new und delete in ZWEI Ausprägungen !!!

new typ    Skalare new
delete ptr

new[] typ     Array new
delete[] ptr



Vergleich zu C#:

    int[] array = new int[5];

    In C# ist array ein OBJECT // length()

    array.length();

==================================================

Zeiger-Arithmetik:

In C++ mit Adressen arbeiten:


int* ip = new int[5];

// Annahme: In ip: 0x1024

ip + 1 

ip:     0x1024
ip + 1: 0x1028

// VORSICHT:

// void*

double* dp = new ....                // double: 8 bytes

dp:       1000;

dp + 1:   1008;

char* cp;     // char: 1 Byte  // Unicode // WChar

cp:     2000

cp + 1: 2001

11:05
=====
