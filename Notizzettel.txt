Seminar C++ Grundlagen und weiterführende Aspekte
=================================================

Peter Loos

Unterlagen:

https://github.com/pelocpp

Dieses Seminar:

https://github.com/pelocpp/cpp_introduction

Modern C++:

https://github.com/pelocpp/cpp_modern

=================================================


30+ Jahre // 20 Jahre Production (C/C++)
             20 Teaching // Java, C#, JavaScript, Mobile Apps (Android), Flutter (Dart)

Knapp 20 Jahre: Siemens Technik Akademie 



Back-to-the-Roots: C++

== Classic C++
== Modern C++ (C++ 11)


C# -- Kenntnisse

Java, Python, Unity, TypeScript (JavaScript)

Welche Sprachen ...
=> Umstieg von C# nach C++
Was sind meine Erwartungen ...
Was MUSS drin sein ...
Was brauche ich ...

Ziel: C++ kennen lernen

=====================================================

ToDo-Liste:

auto: check
lambda :check
Neue Form der Initialisierung check
std::initializer_list<int>

range-based for loop
Utility-Klassen
Folding
constexpr
Lamdbas mit auto

=====================================================

Mittagspause: 12.30 

10.30   // 15.00 ....

=====================================================

2 Tools:

a) Unterlagen:

   Github:

   https://github.com/pelocpp

b) Visual Studio Community (2022 / 2026)

=====================================================


3 Tage C++ Komplett

a) C++ Grundlagen

b) Modern C++


=====================================================

Beobachtung:

Java, C#, Python:

   ==> Höherstehenden Schichten eines SW-Architektur
       zB: Backend Web-Server // Desktopanwendung (C# / .NET Framework)


C++:

   ==> Tiefere Schichten eines SW-Architektur

   Embedded SW // System-SW // Hardware-nahe SW // Desktopanwendung
   System Tools:  Compiler , Debugger  


=====================================================

Beobachtung:

C:  ca. 1980

    Keine OO // rein prozedural

C++: ca. 1985

C ist vom Sprachumfang ECHT in C++ enthalten. (99%)

Konsequenz:

Manche Sprachmittel gibt es in C++ doppelt:

== Pointer   ( C )
== Referenz  ( C++ )

Fazit: Habe ich so eine Situation gegeben: C++ Sprachmittel (nicht: C)

=====================================================


Architektur:
============

Ein Vergleich von C# und C++:

C#: Virtuelle Maschine (CLR)

2 Übersetzungsvorgänge:

A) C# ==> IL

B) JIT: Just-in-Time Compiler: IL => Maschinecode

-----------------------------------------------------

C++:  C++ => Maschinecode

Tooling:

i)  C++ - Compiler
ii) Linker

Verfeinerung:
-------------

Ein C++ Projekt besteht aus vielen Dateien.

C++ => binäres Format (.obj-File // o.-Files )

Spezifikation:  Common Object File Format

Linker: Viele .obj-Dateien ==> Maschinencode (.exe)

Bemerkung:

a) Es gibt Syntax-Fehler:  Grammatik ("compile")
b) Es gibt Linker-Fehler:  zB doppeltes main

==============================================================

Wo liegen Objekte in einem C## / C++ - Programm ???

Im Speicher :)

== Globale Daten
== Stack
== Heap

==============================================================

Stack: Ist ein Speicherbereich :)

Kann nicht wahlweise zugegriffen werden ?!?!?

Nur über den Stackpointer:

Wort Stapel:  Bücherstapel

Wozu ist der Stack so konzipiert ??????

A) Lokale Variablen zu realisieren.
b) Wo geht es nach einem Unterprogrammaufruf weiter ???????

   Es werden PRO Aufruf eines Unterprogramms die Rücksprungadressen
   auch auf dem Stapel abgelegt.


Worüber reden wir gerade:  Stackframe

==============================================================

Heap:

Ist auch ein Speicherbereich.

Wie wird auf den Heap zugegriffen ???

Identisch: C# / C++   Allgemeinen Fall  (  C#:  class  )

new   ==>  Heap  

AUSNAHME:   (( struct:   Stack ))

==============================================================

Stack: Ist ein Speicherbereich :)

Uhhhh: Ein Detail in C#: struct vs. class // Stack vs. Heap

Beispiele:

int malZwei (int a)
{
   int tmp = a;  // Stack
   tmp = 2 * a;
   return tmp;
}

main ()
{
   int a1 = malZwei(5);
   ...

   ....

   int a2 = malZwei(10);
   ...

}


=======================================================

ACHTUNG // VERGLEICH

C#  ===> C++

Klasse Rectangle:   class Rectangle


void tueWas_CSharp()
{
    Rectangle rect1;    // rect ist eine "Referenz" // Pointer // Adresse

    Rectangle rect2 = new Rectangle(10, 20, 40, 50);
}

Eine Referenz ist ein Doppel-Zeiger:  

Zeiger ==> Bucket-Liste // Liste der Objekt-Adressen // ==> Zeiger der tatsächlichen Objekte

new: 2 Funktionalitäten:

     a) Speicher auf dem Heap bereitstellem
     b) Den Konstruktor auf diesem Stück Speicher ausführen

Wann wird dieses Objekt freigegeben:

     a) Wenn es KEINE REFERENZ (Pointer) mehr gibt, der auf dieses Objekt zeigt.

     b) Wer gibt das Unterprogramm frei: SW:  Garbage Collector // GC

        ==> Es gibt in der Tat mehrere REALISIERUNGEN eines solchen GC

        a) Desktop Variante:   Faule Variante (Lazy): Erst, wenn der Speicher knapp wird
        b) Embedded Variante:  Zügig, um Engpässe im Speicher zu vermeiden.

// ----------------------------------------------

// C Sharp
void tueWas_CSharp()
{
    Rectangle rect;    // rect ist eine "Referenz" // Pointer // Adresse // null
}

// C++
void tueWas_Cpp()
{
    // dieses Objekt liegt am STACK
    Rectangle rect1 (10, 10, 30, 40);    // rect ist ein vollständiges Objekt // liegt am STACK !!!

    // dieses Objekt liegt am HEAP
    // In C++ muss der Typ POINTER konkret definiert werden
    Rectangle* rect2 = new Rectangle (10, 10, 30, 40);

   // delete rect2;
}

Gretchenfrage: Wer gibt (C++) das Objekt am Heap  (rect2)  wieder frei ???
   Wir // der entwickler // es muss EXPLIZIT im Programm freigegeben werden !!!


ARCHITEKTUR:

C#:     Referenz-baasierte Sprache  (Heap  // new // GC )

C++:    Referenz-baasierte Sprache  (Heap  // new // delete)

        Stack-basierte Sprache      (Stack)

===========================================================

Ein C++ Projekt mit Visual Studio:

a) Grammatik / Syntax

   == Compile

b) Das Programm bauen

   == Build

Vergleich:

C#:   2-Pass Compiler

C++:  1-Pass Compiler

Alles muss bei einem Übersetzungsdurchlauf bekannt sein !!!

===========================================================

Ein objekt-orientiertes Programm in C++
---------------------------------------

Klasse:  2 Dateien

a) Header-Datei

   ===> Kunden // Benutzer

b) Implementierungs-Datei

   ===> Library // Binärformat

Beispiel:

Uhrzeit:  Klasse Time

Stunden, Minuten und Sekunden.

=============================

Ab C++ 20 / 23:  

The Return of printf (C#:  println)   // Python

============================

C++ Bibliothek:   STL   Standard Template Library

Template == ähnlich zu Generics

=========================================================

C#: Sprachfeature: Property  // implicit get / set

C++: So nicht vorhanden.

   getter / setter

=========================================================

Ein Kern Feature der OO:

Jeder Objekt hat zu JEDEM Zeitpunkt GÜLTIGE Werte in seinen
Instanzvariablen.

a) Initialisierung (Konstruktoren)

b) Während des Lebensdauer eines Objekts (getter/setter // Analogie: Properties C#)


=========================================================

Zu Konstruktoren:

A) Hat die Klasse KEINEN Konstruktor definiert:

   Dann wird der Standard-Konstruktor AUTOMATISCH erzeugt.

   Vorsicht: KEINE Vorbelegung mit Null !!!!!!!!!!!!!!

B) Hat die Klasse EINEN oder MEHRERE Konstruktor definiert:

   Dann sind nur die verfügbar, die es auch gibt.

==============================================================

Stilistik:

this:  Konzipiert als ZEIGER auf das aktuelle Objekt.

class Time:

Time* this;

==============================================================

Aufgabe:

Bankkonto

class BankAccount

== Member: m_balance (double, int)

== Einzahlen, Abheben, Ausgeben

== getter: getBalance

2 Dateien: Header-File, Implementierungs-File

3. Datei: Programm: 

=================================================================

Header-Datei:

Ausnahme von der Regel:

Methoden sind im Header-File implementierbar.

Pro:

== Einfachere Hantierbarkeit

Kontra:

== Eigentlich ist das Header-File für den Benutzer der Klasse konzipiert.
   (  inkl. der Implementierung ??? )

=================================================================

Übergabe von Objekten an Methoden
---------------------------------

Parameterübergabe:
------------------


ARCHITEKTUR:

C#:     Referenz-basierte Sprache  (Heap  // new // GC )

C++:    Referenz-basierte Sprache  (Heap  // new // delete)

        Stack-basierte Sprache      (Stack)


C++ / C:

Parameterübergabe: Per DEFAULT: Call-by-VALUE // Call-by-COPY

Wie kann man in Unterprogrammen auf ORIGINALE zugreifen ?????????????

Wir haben per Default:  Call-by-COPY

2 Lösungen:

A) Pointer   ( C )     // real C/C++


new: <================ Pointer



Wert hinter der Adresse:   05 00 00 00

                            0a 00 00 00




B) Referenz  ( C++ )   // leichter lesbare / schreibbare Weise 

Merkhilfe: Eine Referenz ist im Prinzip die ADRESSE einer Variablen,
            nur mit einer anderen Schreibweise (leichter lesbar sein)

Fazit:

Wozu Referenzen:

Um am STACK Objekte mit ihren ADRESSEN zu bewegen.

Was ist mit dem HEAP ???

Hier gibt es nur POINTER, die mit new ermittelt werden.

Eine Kopie eines Pointers ist KEINE Kopie eines Objekts.

=====================================

Adresse:

void*: Das gibt es so nicht

int*:  Eine int-Variable belegt 4 Bytes im Speicher // sizeof

       Damit sind bei einer int* Adresse  4 BYTEs relevant.


Wert hinter der Adresse:   05 00 00 00

                           0a 00 00 00


// ===================================================

Was ist ein cast:  Typumwandlung ...


========================================================

C:   Pointer-Arithmetik
     Adress-Arithmetik


         ++ip;   Man kann eine Adresse als ganze Zahl auffassen.
                 Folglich kann man 1 draufzählen.

                 1024 => 1025: NEIN
                 1024 => 1028: Korrekt

Wann brauche ich die Adress-Arithmetik:

Bei dynamscher Speicherverwaltung:

new : 100 int Werte  ==> Anfangsadresse.

=======================================================

Anwendung von Referenzen:
-------------------------

Feature:  Schutz von Objekten // 95%: Das gibt es so in C# nicht ....

=========================================================

'int Time::getHours(void)': 

cannot convert 'this' pointer from 'const Time' to 'Time &'

Trick / Hinweis: wenn in der Fehlermeldung 'const' steht, dann ist das in der Regel ein FEHLENDES const.

Frage / Problem: Wo ???

Beobachtung: Einmal 'const', immer 'const'

=========================================================

Ist const nur für die Qualität des Codes (Schutz von Originalen) eine Hilfe ???

NEIN.

2 Aspekt:

Funktionale Programmiersprachen:  Ge-hyped

Performanz:  Merkmal einer Funktion:  Kennt keine Instanzvariablen.

Optimierung:  Pipelining.

Geht nicht bei OO:  ==> State // Member

Ausnahme:  'const'  ==> KEIN schreibender Zugriff auf State

 ==> besser optimieren.

80%:  Java, C#, C++ ...........

// =========================================================

Call by Referenz ist wichtig bei Objekten:

KEINE unnütze Kopie.

Wie sieht es bei elementaren Variablen aus ???

Hier ist call-by-Copy SCHNELLER

EAX: Akku // Rechenregister einer CPU // Hauptregister

RAX:  Register für Adressen

Call-by-Copy:

    int m = value;
00007FF7434B755F  mov         eax,dword ptr [value]  
00007FF7434B7565  mov         dword ptr [m],eax  


Call-by-Ref:

    int m = value;
00007FF7434B75F0  mov         rax,qword ptr [value]  
00007FF7434B75F7  mov         eax,dword ptr [rax]  
00007FF7434B75F9  mov         dword ptr [m],eax  

==============================================================

Überladen von Operatoren

Beispiel:

Vergleich von Objekten

C#:

Universelle Basisklasse Object:   equals  // Überschreiben

Ähnliches zu einem speziellen Operator:  Indexer  // Ähnlich zum operator[]

C++:

operator ==

Technisch:  

Wie das Schreiben einer Methode
Name der Methode:  operator ==

BEMERKUNG: 

Es gibt ZWEI Möglichkeiten, Operatoren zu Überladen:

a) Als "Methode" der Klasse

B) Als globale Funktion


=================================================================

Scharfes Schwert:   friendship   Keyword:   friend       // Clean Code 

Für "Freunde" gilt: Aus private wird public :)

=================================================================


Dynamische Daten

== new und delete

ACHTUNG:

Es gibt new und delete in ZWEI Ausprägungen !!!

new typ    Skalare new
delete ptr

new[] typ     Array new
delete[] ptr



Vergleich zu C#:

    int[] array = new int[5];

    In C# ist array ein OBJECT // length()

    array.length();

==================================================

Zeiger-Arithmetik:

In C++ mit Adressen arbeiten:


int* ip = new int[5];

// Annahme: In ip: 0x1024

ip + 1 

ip:     0x1024
ip + 1: 0x1028

// VORSICHT:

// void*

double* dp = new ....                // double: 8 bytes

dp:       1000;

dp + 1:   1008;

char* cp;     // char: 1 Byte  // Unicode // WChar

cp:     2000

cp + 1: 2001

=================================================================

Betrachtung:

== Klassen verwalten Daten

== Sind dies elementare Variablen:

   zB: Klasse Time

== Sind dies dynamische Variablen:

   Da wird es etwas komplexer - im Vergleich zu C#

   (( Maschinenraum von C++ ))

Beispiel:

Klasse BigData

== Verwaltet ein Feld von int-Variablen

== Wieviele: Unbekannt, bzw. wird durch einen Konstruktor-Aufruf mitgeteilt.


Destruktor  // Finalizer

Diese Methode wird aufgerufen, wenn ein Objekt zerstört wird.

Why not in C#:  Ein Objekt wird in C# zerstört, wenn der GC aktiv ist.

                Nicht-deterministisch. Wann ???????????????

C++: Die Zerstörung ist DETERMINISTISCH.

==============================================================

Zwei weitere Aspekte:

== Das Kopieren von Objekten
== Die Wertzuweisung von Objekten

VORAB:   C#

A) Kopieren: Gibt es so nicht in C#:

   interface ICloneable:  clone 

B) Wertzuweisung:

   Time t = new Time(12, 0, 0,);

   Time t2;

   t2 = t;   // Geht // Wort "Kopie" ?!?!?!

In C++: 

   Time t (12, 0, 0,);

   Time t2;

   t2 = t;   // Geht das in C++: Ja, das geht





// =============================================

Beispiel:

0x0000024256051190

new agiert mit der Freispeicherverwaltung.

Diese verwaltet große Blöcke an Speicher.

Ein Zeiger wird von der Freispeicherverwaltung reserviert ...
und die Reservierung kann wieder zurüchgezogen werden.

===> Danach ist dieser Zeiger NICHT mehr gültig.

REGEL:   EIN new , EIN delete !!!!!!!!!!!!!!!!!!!!!!!!!

// =============================================

Muss ich diese - nicht ganz triviale - Implementierung in C++ IMMER machen ????

==> Es gibt in der STL viele ähnlichen Klassen wie 'BigData':
    Die machen das Automatisch.

==> Modern C++: Smart Pointer:  std::shared, std::unique 

==> Wenn ich in meinen Klassen new auf diese Weise EXPLIZIT Verwende:

    Ja.

// =============================================

Neben der Zuweisung:   operator=

müssen wir analog den Kopier-Konstruktor betrachten.

// =============================================

Bibliothek

Maschinenraum von C++:  „Rule of Three”

==============================================

Alternative:

int* m_data;
int  m_counter;

0 => 1 => 2 => 3 => 2 => 1 => 0


DESTRUKTOR:
{
   m_counter --;

   if (m_counter == 0) {
       delete [] m_data ;
   }
}

==============================================

Mittwoch:

Walk-Through: Modern C++

Templates  // Generics

C++:  STL  // No.

==============================================

STL:  Es ist Standard Bibliothek.

Sie ist in ihrer Struktur etwas "eigen".

==============================================

Überblick:

https://github.com/pelocpp/cpp_clean_performant_secure/blob/master/Clean_Performant_Code/Data_Structures_and_Algorithms/Readme_STL_Container.md

== Container

== Iteratoren // ähnlich zu C#

== Algorithmen ( suchen, durchlaufen, kopieren, vorbelegen, .... )

== Aufrufbare Objekte 



Hash-Tabelle:

Schlüssel ==> Wert   (key, value)

=========================================================

Architektur:

Ziel: Transparenz

== Will einen Container durchlaufen // traversieren

== Das Vorgehen ist für alle Container dasselbe

Container:

Vektoren:  Linear / hintereinander angeordnet

Binären Baum:  std::map

Hash-Tabelle:  std::unordered_map

Linked List:   std::list  // std::forward_list

Linked List list:   list[3]  ginge mit Gewalt.

        Aber warum tut man das nicht ????

        O-Notation: Was wäre eine schlechte Performanz.

        O(n ∗ log n) – Quasi-linearer Aufwand  wird maximal noch unterstützt.

        Alles, was schlechter (langsamer) ist, wird NICHT unterstützt.

// ==============================================================

Was ist /in C++/ ein Iterator???

Beschreibt eine POSITION in einem Container.

Achtung: Das ist nicht der WERT an dieser Position.

Was kann man mit einer Position machen ???

C#:

public object Current { get; }
public bool MoveNext();

C++:

Wert-von:                      * Operator  // Dereferenzieren:  Referenz

Move Next:                     operator ++

Vergleich zweier Positionen:   operator ==

Wie erhalte ich eine Position eines Containers ???????

2 spezielle Methoden:

begin()   Position des ERSTEN Elements
end()     Position des LETZEN Elements  // Exakt: Nach dem letzen  // Nirvana

Von welchem Typ ist eine Position ?????

Jeder Container bringt hierfür seinen eigenen Datentyp mit.

Trick, damit ich ich nicht "Anzahl der Container"  neue Klassen lernen muss:



// Neuland

Algorithmen

============================================================

STL-Container
STL-Iteratoren
Aufrufbare Objekte
STL-Algorithmen

============================================================

Aufrufbare Objekte:

Was ist das ???

class Foo ...
Foo obj;
obj.method();

Frage: Kann man 'obj(params)' auch schreiben

Wieso: obj.method (params);

Eine Klasse, die den Operator operator() überlädt, nennt man 'aufrufbar'.

============================================================


STL-Algorithmen

Diese benötigen:

   == Einen Bereich (von wo nach wo)
   == Eine Funktion, die möglicherweise auf ein Element anzuwenden ist.
      (Schnittstelle)

Technisch:

3 Möglichkeiten:

i)   globale Funktion       - Classic C++
ii)  Aufrufbares Objekt     - Classic C++
iii) Lambda                 - Modern C++

====================================================================

Teuflischen Folge

Zahlenfolge

Startwert:  n, ganze, positive Zahl

Folgewert:

   Wenn n gerade:   n / 2
   Wenn n ungerade: 3 * n + 1

Beispiel:

Startwert: 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1.

Bei 1 ist die Folge zu Ende.

Why "teuflisch":  

Man konnte bis heute NICHT beweisen, dass JEDE teuflische Folge ENDLICH ist.

3, 10, 5, 16, ...

Collatz

Aufgabe:

a) Startwert: int n = 7;   // Einprogrammieren

b) std::vector

c) Das vector mit den Werten der teuflische Folge füllen.

d) Den Vektor mit std::for_each ausgeben.



===========================================

class MyDevilsSequence
{
private:
    int m_start;

public:
    MyDevilsSequence() {
        m_start = 7;
    }

    MyDevilsSequence(int start) {
        m_start = start;
    }

    void operator() () {

           // alles rein // init
    }
};


===========================================
===========================================

Zäsur: Classic C++

Array:

C++:

int numbers[100];                    // Fixed-Size !!!  GLOBAL // STACK

int* numbersHeap = new int[100];     // Fixed-Size !!!  HEAP  // delete[] nicht vergessen


C#:

int[] numbers = new int[100];        // auch Fixed-Size !!!  HEAP

==============================================================

Vererbung:

Technisch: genauso ...

C#: Merkmal / Feature:

Basisklasse Object

Die Klasse System.Object 
Die Equals-Methode
Die GetHashCode-Methode 
Die ToString-Methode
Die GetType-Methode 
Die ReferenceEquals-Methode 
Die MemberwiseClone-Methode 

Mögliche Analogie zu C++:

Die Equals-Methode:  operator==  / operator!=
Die GetHashCode-Methode : Keine Analogie

Konsequenz:  std::map // std::unordered_map: Standardklassen haben eine "versteckte" GetHashCode-Methode

          std::hash ist zu unterstützen von benutzer-definierten Klassen

          Beispiel:

template <>
struct hash<CowString>
{
    // Note: std::hash<const char*> hashes the pointer value, not the characters it points to
    // Workaround: let's use std::string_view

    std::size_t operator() (const CowString& cs) const {

        std::string_view sv{ cs };
        std::size_t h{ std::hash<std::string_view>{}(sv) };
        return h;
    }
};


Beispiel:

Deep-Dive:  Kopieren:  Kopier-Konstruktor

class Time:    Automatisch unterstützt:  Flache Kopie, die es tut
class BigData: Würde automatisch unterstützt werden, aber falsch : Flache Kopie

               Kopier-Konstruktor selbst korrekt schreiben

Dritte Variante: Faules Kopieren // Lazy Copy:   Copy-On-Write

COWString:     ==> Dictionaries  (aufheben): Geht erst mal nicht.

====================================

Die ToString-Methode: Keine Analogie

std::string toString()


Die GetType-Methode : Reflection

C++: : Keine Analogie

VORSICHT:  Reflection for C++26



class Foo

Wirklichkeit:

class Foo : Object

C++:

Nicht vorhanden.

class Foo // Keine Basisklasse

Die ReferenceEquals-Methode : Keine Analogie

Die MemberwiseClone-Methode : Analogie:  (schwach): Kopier-Konstruktor

==========================================================================

Classic C++ zu Modern C++:

auto
Lambda

===========================================================================


auto:

Unterlage:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Auto/Auto.md

Vorsicht:

JavaScript:   KEINE Compile-Time Datentypen
-----------

Dynmamischer Typ // Runtime-Time

var n = 123;

let k = "erwerwe";
    k = 123.123;


VORSICHT: auto ist KEIN Dynmamischer Typ 


==============================================

auto:

i)   Vereinbarung von VAriablen
ii)  Rückgabetyp
iii) Bei Parametern

==============================================

Verlust von const und & (Referenz) bei auto
-------------------------------------------


==============================================

Neue Form der Initialisierung

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/BraceInitialization/BraceInitialization.md

Ab C++ 11:

Neuen Ansatz:  Geschweiften Klammern

Einheitliches Init. Konzept  // Uniform // Brace

Alte Syntax: Geht natürlich weiter ....

==============================================

Achtung: struct   // C++ vs. C#

Sind sehr unterschiedlich:

C#: struct ist ein Value-Type: Eine struct-Variable in C#
    liegt am Stack.

In zB den Libs. Windows Forms, WPF gibt es viele "kleine" Objekte:

Point (10, 20)
Size (10, 20)
Line 
Rectangle

int, double: Value-Type  (CTS, Common Type System)

Object ==> ValueType // ReferenceType  ==> 

Würden all diese Objekte am HEAP liegen:  Das würde in vielerlei Hinsicht unperformant.

Bremse: Kleine Daten auf den Stack

==============================================

Was ist eine struct in C++:

Wurde von C übernommen:

Verbunddatentyp:

struct Time
{
   int hours;
   int minutes;
   int seconds;
}

Besteht NUR aus Variablen.

struct Time now;

struct Time* pnow = new struct Time;  

==============================================

Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a double precision

    
==============================================

C#:   Features:  delegates und events

C++:  Nope

==============================================

Lambda:
=======

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

a) Syntax // Kochrezept

b) Hinter die Kulissen

Why: Viele der "neuen" C++ Konzepte werden auf Vorhandenes abgebildet.

Beispiel:

Sortieren eines Containers:

std::sort

Was ist ein Lambda:

lax:    eine anonyme Methode "inplace"

exakt:  ein Objekt, das den Aufrufoperator operator() besitzt.
        Die dazugehörige Klasse wird vom Compiler erzeugt.
        Sie ist für uns anonym.

Für ein echtes Understanding von Modern C++:

Tool:  Cpp Insights

Kein Online Compiler: 

Converter:  C++ Syntax Modern ==> C++ Syntax Classic.

==============================================================

std::initializer_list<T>

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/InitializerList/InitializerList.md


Ein wichtiges, neues Feature:

i)  Variable Anzahl an Werten (Liste)

ii) Performanz



std::vector:               HEAP

versus

std::initializer_list:     STACK

               Das geht SCHNELLER !!!


std::initializer_list ist kein VOLLWERTIGER STL-Container.

std::initializer_list:

    begin()
    end()
    size()


Stolperfalle:
-------------

std::vector<int> vec(10);     // size(): 10 - Werte: 0

vs.

std::vector<int> vec{ 10 };   // size(): 1  - Wert: 10

=================================================================

Variadische Templates
=====================

Auch in C++ gibt es eine Sprachfeature mit "3 Punkten"


Wir haben oft das Problem:  

Eine Menge von Variablen  // 5 bis 10 Stück

== Will die über einen Methoden-/Funktions-Aufruf im Programm
   von A nach B transportieren.

== Eine Funktion hat deshalb Parameter:  Anzahl ist FIX.

Ab C++ 11: Variadische Templates


    int sum = addierer(1, 2, 3, 4, 5);

Das bekommen wir hin: Nicht mit Core C++ Mitteln.

C++:

== Objekt-Orientierung         Bjarne Stroustrup
== Generische Programmierung   Alexander Stepanov

C++ ===> Bibliothek:  STL (Stepanov)

=================================================================

Folding
=======

Folding ist eine Technik, einen arithm. Ausdruck mit Operatoren
    EFFIZIENT zu berechnen.

Hinweis: Es darf nur EIN Operator sein.


int sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8;

int sum = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;

Syntax: "Grausam"  - geht nur mit Hilfestellung


==========================================================

Übung:

Schreibe eine Funktion:

andAll

bool result = andAll (true, true, true, true, true, true, true, true, true, true);

ergebnis: Wenn alle true ==> true

Wenn einer false: ==> false

bool result = andAll (b1, b2, b3, b4, b5);

ergebnis: b1 && b2 && b3 && b4 && b5    <==== Folding - Ausdruck

